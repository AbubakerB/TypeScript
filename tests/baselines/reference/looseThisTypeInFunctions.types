=== tests/cases/conformance/types/thisType/looseThisTypeInFunctions.ts ===
interface I {
>I : I

    explicitThis(this: this, m: number): number;
>explicitThis : (this: this, m: number) => number
>this : this
>m : number
}
class C implements I {
>C : C
>I : I

    n: number;
>n : number

    explicitThis(this: this, m: number): number {
>explicitThis : (this: this, m: number) => number
>this : this
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : this
>n : number
>m : number
    }
    implicitThis(m: number): number {
>implicitThis : (m: number) => number
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : this
>n : number
>m : number
    }
    explicitVoid(this: void, m: number): number {
>explicitVoid : (m: number) => number
>this : void
>m : number

        return m + 1;
>m + 1 : number
>m : number
>1 : number
    }
}
let c = new C();
>c : C
>new C() : C
>C : typeof C

// c.explicitVoid = c.explicitThis; // error, 'void' is missing everything
let o = { 
>o : { explicitThis: (m: any) => any; implicitThis(m: number): number; }
>{     explicitThis: function (m) { return m },	implicitThis(m: number): number { return m } } : { explicitThis: (m: any) => any; implicitThis(m: number): number; }

    explicitThis: function (m) { return m },
>explicitThis : (m: any) => any
>function (m) { return m } : (m: any) => any
>m : any
>m : any

	implicitThis(m: number): number { return m } 
>implicitThis : (m: number) => number
>m : number
>m : number

};
let i: I = o;
>i : I
>I : I
>o : { explicitThis: (m: any) => any; implicitThis(m: number): number; }

c.explicitVoid = c.implicitThis // ok, implicitThis(this:any)
>c.explicitVoid = c.implicitThis : (m: number) => number
>c.explicitVoid : (m: number) => number
>c : C
>explicitVoid : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number

o.implicitThis = c.implicitThis; // ok, implicitThis(this:any)
>o.implicitThis = c.implicitThis : (m: number) => number
>o.implicitThis : (m: number) => number
>o : { explicitThis: (m: any) => any; implicitThis(m: number): number; }
>implicitThis : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number

o.implicitThis = c.explicitThis; // ok, implicitThis(this:any) is assignable to explicitThis(this: this)
>o.implicitThis = c.explicitThis : (this: C, m: number) => number
>o.implicitThis : (m: number) => number
>o : { explicitThis: (m: any) => any; implicitThis(m: number): number; }
>implicitThis : (m: number) => number
>c.explicitThis : (this: C, m: number) => number
>c : C
>explicitThis : (this: C, m: number) => number

o.implicitThis = i.explicitThis;
>o.implicitThis = i.explicitThis : (this: I, m: number) => number
>o.implicitThis : (m: number) => number
>o : { explicitThis: (m: any) => any; implicitThis(m: number): number; }
>implicitThis : (m: number) => number
>i.explicitThis : (this: I, m: number) => number
>i : I
>explicitThis : (this: I, m: number) => number

