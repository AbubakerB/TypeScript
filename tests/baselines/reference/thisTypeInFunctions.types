=== tests/cases/conformance/types/thisType/thisTypeInFunctions.ts ===
// body checking
class C {
>C : C

    n: number;
>n : number

    explicitThis(this: this, m: number): number {
>explicitThis : (m: number) => number
>this : this
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : this
>n : number
>m : number
    }
    implicitThis(m: number): number {
>implicitThis : (m: number) => number
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : this
>n : number
>m : number
    }
    explicitC(this: C, m: number): number {
>explicitC : (m: number) => number
>this : C
>C : C
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number
    }
    explicitProperty(this: {n: number}, m: number): number {
>explicitProperty : (m: number) => number
>this : { n: number; }
>n : number
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : { n: number; }
>n : number
>m : number
    }
    explicitVoid(this: void, m: number): number {
>explicitVoid : (m: number) => number
>this : void
>m : number

        return m + 1;
>m + 1 : number
>m : number
>1 : number
    }
}
class D extends C { }
>D : D
>C : C

class B {
>B : B

    n: number;
>n : number
}
interface I {
>I : I

    a: number;
>a : number

    explicitVoid1(this: void): number;
>explicitVoid1 : () => number
>this : void

    explicitVoid2(this: void): number;
>explicitVoid2 : () => number
>this : void

    explicitStructural(this: {a: number}): number;
>explicitStructural : () => number
>this : { a: number; }
>a : number

    explicitInterface(this: I): number;
>explicitInterface : () => number
>this : I
>I : I

    explicitThis(this: this): number;
>explicitThis : () => number
>this : this

    implicitMethod(): number;
>implicitMethod : () => number

    implicitFunction: () => number;
>implicitFunction : () => number
}
function explicitStructural(this: { y: number }, x: number): number {
>explicitStructural : (x: number) => number
>this : { y: number; }
>y : number
>x : number

    return x + this.y;
>x + this.y : number
>x : number
>this.y : number
>this : { y: number; }
>y : number
}
function justThis(this: { y: number }): number {
>justThis : () => number
>this : { y: number; }
>y : number

    return this.y;
>this.y : number
>this : { y: number; }
>y : number
}
function implicitThis(n: number): number {
>implicitThis : (n: number) => number
>n : number

    return 12;
>12 : number
}
let impl: I = {
>impl : I
>I : I
>{    a: 12,    explicitVoid2: () => this.a, // ok, this: any because it refers to some outer object (window?)    explicitVoid1() { return 12; },    explicitStructural() {        return this.a;    },    explicitInterface() {        return this.a;    },    explicitThis() {        return this.a;    },    implicitMethod() {        return this.a;    },    implicitFunction: () => this.a, // ok, this: any because it refers to some outer object (window?)} : { a: number; explicitVoid2: () => any; explicitVoid1(): number; explicitStructural(): number; explicitInterface(): number; explicitThis(): number; implicitMethod(): number; implicitFunction: () => any; }

    a: 12,
>a : number
>12 : number

    explicitVoid2: () => this.a, // ok, this: any because it refers to some outer object (window?)
>explicitVoid2 : () => any
>() => this.a : () => any
>this.a : any
>this : any
>a : any

    explicitVoid1() { return 12; },
>explicitVoid1 : () => number
>12 : number

    explicitStructural() {
>explicitStructural : () => number

        return this.a;
>this.a : number
>this : { a: number; }
>a : number

    },
    explicitInterface() {
>explicitInterface : () => number

        return this.a;
>this.a : number
>this : I
>a : number

    },
    explicitThis() {
>explicitThis : () => number

        return this.a;
>this.a : number
>this : I
>a : number

    },
    implicitMethod() {
>implicitMethod : () => number

        return this.a;
>this.a : number
>this : I
>a : number

    },
    implicitFunction: () => this.a, // ok, this: any because it refers to some outer object (window?)
>implicitFunction : () => any
>() => this.a : () => any
>this.a : any
>this : any
>a : any
}
impl.explicitVoid1 = function () { return 12; };
>impl.explicitVoid1 = function () { return 12; } : () => number
>impl.explicitVoid1 : () => number
>impl : I
>explicitVoid1 : () => number
>function () { return 12; } : () => number
>12 : number

impl.explicitVoid2 = () => 12;
>impl.explicitVoid2 = () => 12 : () => number
>impl.explicitVoid2 : () => number
>impl : I
>explicitVoid2 : () => number
>() => 12 : () => number
>12 : number

impl.explicitStructural = function() { return this.a; };
>impl.explicitStructural = function() { return this.a; } : () => number
>impl.explicitStructural : () => number
>impl : I
>explicitStructural : () => number
>function() { return this.a; } : () => number
>this.a : number
>this : { a: number; }
>a : number

impl.explicitInterface = function() { return this.a; };
>impl.explicitInterface = function() { return this.a; } : () => number
>impl.explicitInterface : () => number
>impl : I
>explicitInterface : () => number
>function() { return this.a; } : () => number
>this.a : number
>this : I
>a : number

impl.explicitStructural = () => 12;
>impl.explicitStructural = () => 12 : () => number
>impl.explicitStructural : () => number
>impl : I
>explicitStructural : () => number
>() => 12 : () => number
>12 : number

impl.explicitInterface = () => 12;
>impl.explicitInterface = () => 12 : () => number
>impl.explicitInterface : () => number
>impl : I
>explicitInterface : () => number
>() => 12 : () => number
>12 : number

impl.explicitThis = function () { return this.a; };
>impl.explicitThis = function () { return this.a; } : () => number
>impl.explicitThis : () => number
>impl : I
>explicitThis : () => number
>function () { return this.a; } : () => number
>this.a : number
>this : I
>a : number

impl.implicitMethod = function () { return this.a; };
>impl.implicitMethod = function () { return this.a; } : () => number
>impl.implicitMethod : () => number
>impl : I
>implicitMethod : () => number
>function () { return this.a; } : () => number
>this.a : number
>this : I
>a : number

impl.implicitMethod = () => 12;
>impl.implicitMethod = () => 12 : () => number
>impl.implicitMethod : () => number
>impl : I
>implicitMethod : () => number
>() => 12 : () => number
>12 : number

impl.implicitFunction = () => this.a; // ok, this: any because it refers to some outer object (window?)
>impl.implicitFunction = () => this.a : () => any
>impl.implicitFunction : () => number
>impl : I
>implicitFunction : () => number
>() => this.a : () => any
>this.a : any
>this : any
>a : any

// parameter checking
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f: explicitStructural };
>ok : { y: number; f: (x: number) => number; }
>y : number
>f : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>{ y: 12, f: explicitStructural } : { y: number; f: (x: number) => number; }
>y : number
>12 : number
>f : (x: number) => number
>explicitStructural : (x: number) => number

let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: implicitThis };
>implicitAnyOk : { notSpecified: number; f: (x: number) => number; }
>notSpecified : number
>f : (x: number) => number
>x : number
>{ notSpecified: 12, f: implicitThis } : { notSpecified: number; f: (n: number) => number; }
>notSpecified : number
>12 : number
>f : (n: number) => number
>implicitThis : (n: number) => number

ok.f(13);
>ok.f(13) : number
>ok.f : (x: number) => number
>ok : { y: number; f: (x: number) => number; }
>f : (x: number) => number
>13 : number

implicitThis(12);
>implicitThis(12) : number
>implicitThis : (n: number) => number
>12 : number

implicitAnyOk.f(12);
>implicitAnyOk.f(12) : number
>implicitAnyOk.f : (x: number) => number
>implicitAnyOk : { notSpecified: number; f: (x: number) => number; }
>f : (x: number) => number
>12 : number

let c = new C();
>c : C
>new C() : C
>C : typeof C

let d = new D();
>d : D
>new D() : D
>D : typeof D

let ripped = c.explicitC;
>ripped : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number

c.explicitC(12);
>c.explicitC(12) : number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>12 : number

c.explicitProperty(12);
>c.explicitProperty(12) : number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>12 : number

c.explicitThis(12);
>c.explicitThis(12) : number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>12 : number

c.implicitThis(12);
>c.implicitThis(12) : number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number
>12 : number

d.explicitC(12);
>d.explicitC(12) : number
>d.explicitC : (m: number) => number
>d : D
>explicitC : (m: number) => number
>12 : number

d.explicitProperty(12);
>d.explicitProperty(12) : number
>d.explicitProperty : (m: number) => number
>d : D
>explicitProperty : (m: number) => number
>12 : number

d.explicitThis(12);
>d.explicitThis(12) : number
>d.explicitThis : (m: number) => number
>d : D
>explicitThis : (m: number) => number
>12 : number

d.implicitThis(12);
>d.implicitThis(12) : number
>d.implicitThis : (m: number) => number
>d : D
>implicitThis : (m: number) => number
>12 : number

let reconstructed: { 
>reconstructed : { n: number; explicitThis(m: number): number; implicitThis(m: number): number; explicitC(m: number): number; explicitProperty: (m: number) => number; explicitVoid(m: number): number; }

    n: number,
>n : number

    explicitThis(this: C, m: number): number, // note: this: this is not allowed in an object literal type.
>explicitThis : (m: number) => number
>this : C
>C : C
>m : number

    implicitThis(m: number): number,
>implicitThis : (m: number) => number
>m : number

    explicitC(this: C, m: number): number,
>explicitC : (m: number) => number
>this : C
>C : C
>m : number

    explicitProperty: (this: {n : number}, m: number) => number,
>explicitProperty : (m: number) => number
>this : { n: number; }
>n : number
>m : number

    explicitVoid(this: void, m: number): number,
>explicitVoid : (m: number) => number
>this : void
>m : number

} = { 
>{     n: 12,    explicitThis: c.explicitThis,    implicitThis: c.implicitThis,    explicitC: c.explicitC,    explicitProperty: c.explicitProperty,    explicitVoid: c.explicitVoid} : { n: number; explicitThis: (m: number) => number; implicitThis: (m: number) => number; explicitC: (m: number) => number; explicitProperty: (m: number) => number; explicitVoid: (m: number) => number; }

    n: 12,
>n : number
>12 : number

    explicitThis: c.explicitThis,
>explicitThis : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number

    implicitThis: c.implicitThis,
>implicitThis : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number

    explicitC: c.explicitC,
>explicitC : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number

    explicitProperty: c.explicitProperty,
>explicitProperty : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number

    explicitVoid: c.explicitVoid
>explicitVoid : (m: number) => number
>c.explicitVoid : (m: number) => number
>c : C
>explicitVoid : (m: number) => number

};
reconstructed.explicitProperty(11);
>reconstructed.explicitProperty(11) : number
>reconstructed.explicitProperty : (m: number) => number
>reconstructed : { n: number; explicitThis(m: number): number; implicitThis(m: number): number; explicitC(m: number): number; explicitProperty: (m: number) => number; explicitVoid(m: number): number; }
>explicitProperty : (m: number) => number
>11 : number

reconstructed.implicitThis(11);
>reconstructed.implicitThis(11) : number
>reconstructed.implicitThis : (m: number) => number
>reconstructed : { n: number; explicitThis(m: number): number; implicitThis(m: number): number; explicitC(m: number): number; explicitProperty: (m: number) => number; explicitVoid(m: number): number; }
>implicitThis : (m: number) => number
>11 : number

// assignment checking
let unboundToSpecified: (this: { y: number }, x: number) => number = x => x + this.y; // ok, this:any
>unboundToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>x => x + this.y : (x: number) => any
>x : number
>x + this.y : any
>x : number
>this.y : any
>this : any
>y : any

let specifiedToSpecified: (this: {y: number}, x: number) => number = explicitStructural;
>specifiedToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>explicitStructural : (x: number) => number

let anyToSpecified: (this: { y: number }, x: number) => number = function(x: number): number { return x + 12; };
>anyToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>function(x: number): number { return x + 12; } : (x: number) => number
>x : number
>x + 12 : number
>x : number
>12 : number

let unspecifiedLambda: (x: number) => number = x => x + 12;
>unspecifiedLambda : (x: number) => number
>x : number
>x => x + 12 : (x: number) => number
>x : number
>x + 12 : number
>x : number
>12 : number

let specifiedLambda: (this: void, x: number) => number = x => x + 12;
>specifiedLambda : (x: number) => number
>this : void
>x : number
>x => x + 12 : (x: number) => number
>x : number
>x + 12 : number
>x : number
>12 : number

let unspecifiedLambdaToSpecified: (this: {y: number}, x: number) => number = unspecifiedLambda;
>unspecifiedLambdaToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>unspecifiedLambda : (x: number) => number

let specifiedLambdaToSpecified: (this: {y: number}, x: number) => number = specifiedLambda;
>specifiedLambdaToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>specifiedLambda : (x: number) => number


let explicitCFunction: (this: C, m: number) => number;
>explicitCFunction : (m: number) => number
>this : C
>C : C
>m : number

let explicitPropertyFunction: (this: {n: number}, m: number) => number;
>explicitPropertyFunction : (m: number) => number
>this : { n: number; }
>n : number
>m : number

c.explicitC = explicitCFunction;
>c.explicitC = explicitCFunction : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>explicitCFunction : (m: number) => number

c.explicitC = function(this: C, m: number) { return this.n + m };
>c.explicitC = function(this: C, m: number) { return this.n + m } : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>function(this: C, m: number) { return this.n + m } : (m: number) => number
>this : C
>C : C
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

c.explicitProperty = explicitPropertyFunction;
>c.explicitProperty = explicitPropertyFunction : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>explicitPropertyFunction : (m: number) => number

c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m };
>c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m } : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>function(this: {n: number}, m: number) { return this.n + m } : (m: number) => number
>this : { n: number; }
>n : number
>m : number
>this.n + m : number
>this.n : number
>this : { n: number; }
>n : number
>m : number

c.explicitProperty = reconstructed.explicitProperty;
>c.explicitProperty = reconstructed.explicitProperty : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>reconstructed.explicitProperty : (m: number) => number
>reconstructed : { n: number; explicitThis(m: number): number; implicitThis(m: number): number; explicitC(m: number): number; explicitProperty: (m: number) => number; explicitVoid(m: number): number; }
>explicitProperty : (m: number) => number

// lambdas are assignable to anything
c.explicitC = m => m;
>c.explicitC = m => m : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>m => m : (m: number) => number
>m : number
>m : number

c.explicitThis = m => m;
>c.explicitThis = m => m : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>m => m : (m: number) => number
>m : number
>m : number

c.explicitProperty = m => m;
>c.explicitProperty = m => m : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>m => m : (m: number) => number
>m : number
>m : number

// this inside lambdas refer to outer scope
// the outer-scoped lambda at top-level is still just `any`
c.explicitC = m => m + this.n;
>c.explicitC = m => m + this.n : (m: number) => any
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>m => m + this.n : (m: number) => any
>m : number
>m + this.n : any
>m : number
>this.n : any
>this : any
>n : any

c.explicitThis = m => m + this.n;
>c.explicitThis = m => m + this.n : (m: number) => any
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>m => m + this.n : (m: number) => any
>m : number
>m + this.n : any
>m : number
>this.n : any
>this : any
>n : any

c.explicitProperty = m => m + this.n;
>c.explicitProperty = m => m + this.n : (m: number) => any
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>m => m + this.n : (m: number) => any
>m : number
>m + this.n : any
>m : number
>this.n : any
>this : any
>n : any

//NOTE: this=C here, I guess?
c.explicitThis = explicitCFunction;
>c.explicitThis = explicitCFunction : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>explicitCFunction : (m: number) => number

c.explicitThis = function(this: C, m: number) { return this.n + m };
>c.explicitThis = function(this: C, m: number) { return this.n + m } : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>function(this: C, m: number) { return this.n + m } : (m: number) => number
>this : C
>C : C
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

// this:any compatibility
c.explicitC = function(m: number) { return this.n + m };
>c.explicitC = function(m: number) { return this.n + m } : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => number
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

c.explicitProperty = function(m: number) { return this.n + m };
>c.explicitProperty = function(m: number) { return this.n + m } : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => number
>m : number
>this.n + m : number
>this.n : number
>this : { n: number; }
>n : number
>m : number

c.explicitThis = function(m: number) { return this.n + m };
>c.explicitThis = function(m: number) { return this.n + m } : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => number
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

c.implicitThis = function(m: number) { return this.n + m };
>c.implicitThis = function(m: number) { return this.n + m } : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => number
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

c.implicitThis = reconstructed.implicitThis;
>c.implicitThis = reconstructed.implicitThis : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number
>reconstructed.implicitThis : (m: number) => number
>reconstructed : { n: number; explicitThis(m: number): number; implicitThis(m: number): number; explicitC(m: number): number; explicitProperty: (m: number) => number; explicitVoid(m: number): number; }
>implicitThis : (m: number) => number

c.explicitC = function(this: B, m: number) { return this.n + m };
>c.explicitC = function(this: B, m: number) { return this.n + m } : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>function(this: B, m: number) { return this.n + m } : (m: number) => number
>this : B
>B : B
>m : number
>this.n + m : number
>this.n : number
>this : B
>n : number
>m : number

// this:void compatibility
c.explicitVoid = n => n;
>c.explicitVoid = n => n : (n: number) => number
>c.explicitVoid : (m: number) => number
>c : C
>explicitVoid : (m: number) => number
>n => n : (n: number) => number
>n : number
>n : number

// class-based assignability
class Base1 {
>Base1 : Base1

    x: number;
>x : number

    public implicit(): number { return this.x; }
>implicit : () => number
>this.x : number
>this : this
>x : number

    explicit(this: Base1): number { return this.x; }
>explicit : () => number
>this : Base1
>Base1 : Base1
>this.x : number
>this : Base1
>x : number

    static implicitStatic(): number { return this.y; }
>implicitStatic : () => number
>this.y : number
>this : typeof Base1
>y : number

    static explicitStatic(this: typeof Base1): number { return this.y; }
>explicitStatic : () => number
>this : typeof Base1
>Base1 : typeof Base1
>this.y : number
>this : typeof Base1
>y : number

    static y: number;
>y : number

}
class Derived1 extends Base1 {
>Derived1 : Derived1
>Base1 : Base1

    y: number
>y : number
}
class Base2 {
>Base2 : Base2

    y: number
>y : number

    implicit(): number { return this.y; }
>implicit : () => number
>this.y : number
>this : this
>y : number

    explicit(this: Base1): number { return this.x; }
>explicit : () => number
>this : Base1
>Base1 : Base1
>this.x : number
>this : Base1
>x : number
}
class Derived2 extends Base2 {
>Derived2 : Derived2
>Base2 : Base2

    x: number
>x : number
}
let b1 = new Base1();
>b1 : Base1
>new Base1() : Base1
>Base1 : typeof Base1

let b2 = new Base2();
>b2 : Base2
>new Base2() : Base2
>Base2 : typeof Base2

let d1 = new Derived1();
>d1 : Derived1
>new Derived1() : Derived1
>Derived1 : typeof Derived1

let d2 = new Derived2();
>d2 : Derived2
>new Derived2() : Derived2
>Derived2 : typeof Derived2

d2.implicit = d1.implicit // ok, 'x' and 'y' in { x, y } (d assignable to f and vice versa)
>d2.implicit = d1.implicit : () => number
>d2.implicit : () => number
>d2 : Derived2
>implicit : () => number
>d1.implicit : () => number
>d1 : Derived1
>implicit : () => number

d1.implicit = d2.implicit // ok, 'x' and 'y' in { x, y } (f assignable to d and vice versa)
>d1.implicit = d2.implicit : () => number
>d1.implicit : () => number
>d1 : Derived1
>implicit : () => number
>d2.implicit : () => number
>d2 : Derived2
>implicit : () => number

// bivariance-allowed cases
d1.implicit = b2.implicit // ok, 'y' in D: { x, y } (d assignable e) 
>d1.implicit = b2.implicit : () => number
>d1.implicit : () => number
>d1 : Derived1
>implicit : () => number
>b2.implicit : () => number
>b2 : Base2
>implicit : () => number

d2.implicit = d1.explicit // ok, 'y' in { x, y } (c assignable to f)
>d2.implicit = d1.explicit : () => number
>d2.implicit : () => number
>d2 : Derived2
>implicit : () => number
>d1.explicit : () => number
>d1 : Derived1
>explicit : () => number

b1.implicit = d2.implicit // ok, 'x' and 'y' not in C: { x } (c assignable to f) 
>b1.implicit = d2.implicit : () => number
>b1.implicit : () => number
>b1 : Base1
>implicit : () => number
>d2.implicit : () => number
>d2 : Derived2
>implicit : () => number

b1.explicit = d2.implicit // ok, 'x' and 'y' not in C: { x } (c assignable to f)
>b1.explicit = d2.implicit : () => number
>b1.explicit : () => number
>b1 : Base1
>explicit : () => number
>d2.implicit : () => number
>d2 : Derived2
>implicit : () => number

////// use this-type for construction with new ////
function InterfaceThis(this: I) {
>InterfaceThis : () => void
>this : I
>I : I

    this.a = 12;
>this.a = 12 : number
>this.a : number
>this : I
>a : number
>12 : number
}
function LiteralTypeThis(this: {x: string}) {
>LiteralTypeThis : () => void
>this : { x: string; }
>x : string

    this.x = "ok";
>this.x = "ok" : string
>this.x : string
>this : { x: string; }
>x : string
>"ok" : string
}
function AnyThis(this: any) {
>AnyThis : () => void
>this : any

    this.x = "ok";
>this.x = "ok" : string
>this.x : any
>this : any
>x : any
>"ok" : string
}
let interfaceThis = new InterfaceThis();
>interfaceThis : I
>new InterfaceThis() : I
>InterfaceThis : () => void

let literalTypeThis = new LiteralTypeThis();
>literalTypeThis : { x: string; }
>new LiteralTypeThis() : { x: string; }
>LiteralTypeThis : () => void

let anyThis = new AnyThis();
>anyThis : any
>new AnyThis() : any
>AnyThis : () => void

//// type parameter inference ////
declare var f: { 
>f : { (x: number): number; call<U>(...argArray: any[]): U; }

    (this: void, x: number): number, 
>this : void
>x : number

    call<U>(this: (...argArray: any[]) => U, ...argArray: any[]): U;
>call : <U>(...argArray: any[]) => U
>U : U
>this : (...argArray: any[]) => U
>argArray : any[]
>U : U
>argArray : any[]
>U : U

};
let n: number = f.call(12);
>n : number
>f.call(12) : number
>f.call : <U>(...argArray: any[]) => U
>f : { (x: number): number; call<U>(...argArray: any[]): U; }
>call : <U>(...argArray: any[]) => U
>12 : number

