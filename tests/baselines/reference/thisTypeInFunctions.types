=== tests/cases/conformance/types/thisType/thisTypeInFunctions.ts ===
// body checking
class C {
>C : C

    n: number;
>n : number

    explicitThis(this: this, m: number): number {
>explicitThis : (m: number) => number
>this : this
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : this
>n : number
>m : number
    }
    implicitThis(m: number): number {
>implicitThis : (m: number) => number
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : this
>n : number
>m : number
    }
    explicitC(this: C, m: number): number {
>explicitC : (m: number) => number
>this : C
>C : C
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number
    }
    explicitProperty(this: {n: number}, m: number): number {
>explicitProperty : (m: number) => number
>this : { n: number; }
>n : number
>m : number

        return this.n + m;
>this.n + m : number
>this.n : number
>this : { n: number; }
>n : number
>m : number
    }
    explicitVoid(this: void, m: number): number {
>explicitVoid : (m: number) => number
>this : void
>m : number

        return m + 1;
>m + 1 : number
>m : number
>1 : number
    }
}
class D extends C { }
>D : D
>C : C

class B {
>B : B

    n: number;
>n : number
}
interface I {
>I : I

    a: number;
>a : number

    explicitVoid1(this: void): number;
>explicitVoid1 : () => number
>this : void

    explicitVoid2(this: void): number;
>explicitVoid2 : () => number
>this : void

    explicitStructural(this: {a: number}): number;
>explicitStructural : () => number
>this : { a: number; }
>a : number

    explicitInterface(this: I): number;
>explicitInterface : () => number
>this : I
>I : I

    // explicitThis(this: this): number; // TODO: Allow `this` types for interfaces
    implicitMethod(): number; // defaults to `this` :(
>implicitMethod : () => number

    implicitFunction: () => number;
>implicitFunction : () => number
}
function f(this: { y: number }, x: number): number {
>f : (x: number) => number
>this : { y: number; }
>y : number
>x : number

    return x + this.y;
>x + this.y : number
>x : number
>this.y : number
>this : { y: number; }
>y : number
}
function justThis(this: { y: number }): number {
>justThis : () => number
>this : { y: number; }
>y : number

    return this.y;
>this.y : number
>this : { y: number; }
>y : number
}
function implicitThis(n: number): number {
>implicitThis : (n: number) => number
>n : number

    return 12;
>12 : number
}
let impl: I = {
>impl : I
>I : I
>{    a: 12,    explicitVoid2: () => this.a, // ok, this: any because it refers to some outer object (window?)    explicitVoid1() { return 12; },    explicitStructural() {        return this.a;    },    explicitInterface() {        return this.a;    },    //explicitThis() {        //return this.a;    //}    implicitMethod() {        return this.a;    },    implicitFunction: () => this.a, // ok, this: any because it refers to some outer object (window?)} : { a: number; explicitVoid2: () => any; explicitVoid1(): number; explicitStructural(): number; explicitInterface(): number; implicitMethod(): any; implicitFunction: () => any; }

    a: 12,
>a : number
>12 : number

    explicitVoid2: () => this.a, // ok, this: any because it refers to some outer object (window?)
>explicitVoid2 : () => any
>() => this.a : () => any
>this.a : any
>this : any
>a : any

    explicitVoid1() { return 12; },
>explicitVoid1 : () => number
>12 : number

    explicitStructural() {
>explicitStructural : () => number

        return this.a;
>this.a : number
>this : { a: number; }
>a : number

    },
    explicitInterface() {
>explicitInterface : () => number

        return this.a;
>this.a : number
>this : I
>a : number

    },
    //explicitThis() {
        //return this.a;
    //}
    implicitMethod() {
>implicitMethod : () => any

        return this.a;
>this.a : any
>this : any
>a : any

    },
    implicitFunction: () => this.a, // ok, this: any because it refers to some outer object (window?)
>implicitFunction : () => any
>() => this.a : () => any
>this.a : any
>this : any
>a : any
}
impl.explicitVoid1 = function () { return 12; };
>impl.explicitVoid1 = function () { return 12; } : () => number
>impl.explicitVoid1 : () => number
>impl : I
>explicitVoid1 : () => number
>function () { return 12; } : () => number
>12 : number

impl.explicitVoid2 = () => 12;
>impl.explicitVoid2 = () => 12 : () => number
>impl.explicitVoid2 : () => number
>impl : I
>explicitVoid2 : () => number
>() => 12 : () => number
>12 : number

impl.explicitStructural = function() { return this.a; };
>impl.explicitStructural = function() { return this.a; } : () => number
>impl.explicitStructural : () => number
>impl : I
>explicitStructural : () => number
>function() { return this.a; } : () => number
>this.a : number
>this : { a: number; }
>a : number

impl.explicitInterface = function() { return this.a; };
>impl.explicitInterface = function() { return this.a; } : () => number
>impl.explicitInterface : () => number
>impl : I
>explicitInterface : () => number
>function() { return this.a; } : () => number
>this.a : number
>this : I
>a : number

impl.explicitStructural = () => 12;
>impl.explicitStructural = () => 12 : () => number
>impl.explicitStructural : () => number
>impl : I
>explicitStructural : () => number
>() => 12 : () => number
>12 : number

impl.explicitInterface = () => 12;
>impl.explicitInterface = () => 12 : () => number
>impl.explicitInterface : () => number
>impl : I
>explicitInterface : () => number
>() => 12 : () => number
>12 : number

// impl.explicitThis = function () { return this.a; };
impl.implicitMethod = function () { return this.a; };
>impl.implicitMethod = function () { return this.a; } : () => any
>impl.implicitMethod : () => number
>impl : I
>implicitMethod : () => number
>function () { return this.a; } : () => any
>this.a : any
>this : any
>a : any

impl.implicitFunction = function () { return this.a; }; // ok, this: any because it refers to some outer object (window?)
>impl.implicitFunction = function () { return this.a; } : () => any
>impl.implicitFunction : () => number
>impl : I
>implicitFunction : () => number
>function () { return this.a; } : () => any
>this.a : any
>this : any
>a : any

impl.implicitMethod = () => 12;
>impl.implicitMethod = () => 12 : () => number
>impl.implicitMethod : () => number
>impl : I
>implicitMethod : () => number
>() => 12 : () => number
>12 : number

impl.implicitFunction = () => 12;
>impl.implicitFunction = () => 12 : () => number
>impl.implicitFunction : () => number
>impl : I
>implicitFunction : () => number
>() => 12 : () => number
>12 : number

// parameter checking
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f };
>ok : { y: number; f: (x: number) => number; }
>y : number
>f : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>{ y: 12, f } : { y: number; f: (x: number) => number; }
>y : number
>12 : number
>f : (x: number) => number

let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: implicitThis };
>implicitAnyOk : { notSpecified: number; f: (x: number) => number; }
>notSpecified : number
>f : (x: number) => number
>x : number
>{ notSpecified: 12, f: implicitThis } : { notSpecified: number; f: (n: number) => number; }
>notSpecified : number
>12 : number
>f : (n: number) => number
>implicitThis : (n: number) => number

ok.f(13);
>ok.f(13) : number
>ok.f : (x: number) => number
>ok : { y: number; f: (x: number) => number; }
>f : (x: number) => number
>13 : number

implicitThis(12);
>implicitThis(12) : number
>implicitThis : (n: number) => number
>12 : number

implicitAnyOk.f(12);
>implicitAnyOk.f(12) : number
>implicitAnyOk.f : (x: number) => number
>implicitAnyOk : { notSpecified: number; f: (x: number) => number; }
>f : (x: number) => number
>12 : number

let c = new C();
>c : C
>new C() : C
>C : typeof C

let d = new D();
>d : D
>new D() : D
>D : typeof D

let ripped = c.explicitC;
>ripped : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number

c.explicitC(12);
>c.explicitC(12) : number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>12 : number

c.explicitProperty(12);
>c.explicitProperty(12) : number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>12 : number

c.explicitThis(12);
>c.explicitThis(12) : number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>12 : number

c.implicitThis(12);
>c.implicitThis(12) : number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number
>12 : number

d.explicitC(12);
>d.explicitC(12) : number
>d.explicitC : (m: number) => number
>d : D
>explicitC : (m: number) => number
>12 : number

d.explicitProperty(12);
>d.explicitProperty(12) : number
>d.explicitProperty : (m: number) => number
>d : D
>explicitProperty : (m: number) => number
>12 : number

d.explicitThis(12);
>d.explicitThis(12) : number
>d.explicitThis : (m: number) => number
>d : D
>explicitThis : (m: number) => number
>12 : number

d.implicitThis(12);
>d.implicitThis(12) : number
>d.implicitThis : (m: number) => number
>d : D
>implicitThis : (m: number) => number
>12 : number

let reconstructed: { 
>reconstructed : { explicitProperty: (m: number) => number; implicitThis: (m: number) => number; n: number; }

    explicitProperty: (this: {n : number}, m: number) => number,
>explicitProperty : (m: number) => number
>this : { n: number; }
>n : number
>m : number

    implicitThis: (m: number) => number,
>implicitThis : (m: number) => number
>m : number

    n: number,
>n : number

} = { 
>{     explicitProperty: c.explicitProperty,     implicitThis: c.implicitThis,    n: 12 } : { explicitProperty: (m: number) => number; implicitThis: (m: number) => number; n: number; }

    explicitProperty: c.explicitProperty, 
>explicitProperty : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number

    implicitThis: c.implicitThis,
>implicitThis : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number

    n: 12 
>n : number
>12 : number

};
reconstructed.explicitProperty(11);
>reconstructed.explicitProperty(11) : number
>reconstructed.explicitProperty : (m: number) => number
>reconstructed : { explicitProperty: (m: number) => number; implicitThis: (m: number) => number; n: number; }
>explicitProperty : (m: number) => number
>11 : number

reconstructed.implicitThis(11);
>reconstructed.implicitThis(11) : number
>reconstructed.implicitThis : (m: number) => number
>reconstructed : { explicitProperty: (m: number) => number; implicitThis: (m: number) => number; n: number; }
>implicitThis : (m: number) => number
>11 : number

// assignment checking
let specifiedToAny: (x: number) => number = f;
>specifiedToAny : (x: number) => number
>x : number
>f : (x: number) => number

let specifiedToSpecified: (this: {y: number}, x: number) => number = f;
>specifiedToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>f : (x: number) => number

let anyToSpecified: (this: { y: number }, x: number) => number = function(x: number): number { return x + 12; };
>anyToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>function(x: number): number { return x + 12; } : (x: number) => number
>x : number
>x + 12 : number
>x : number
>12 : number

let unspecifiedLambda: (x: number) => number = x => x + 12;
>unspecifiedLambda : (x: number) => number
>x : number
>x => x + 12 : (x: number) => number
>x : number
>x + 12 : number
>x : number
>12 : number

let specifiedLambda: (this: void, x: number) => number = x => x + 12;
>specifiedLambda : (x: number) => number
>this : void
>x : number
>x => x + 12 : (x: number) => number
>x : number
>x + 12 : number
>x : number
>12 : number

let unspecifiedLambdaToSpecified: (this: {y: number}, x: number) => number = unspecifiedLambda;
>unspecifiedLambdaToSpecified : (x: number) => number
>this : { y: number; }
>y : number
>x : number
>unspecifiedLambda : (x: number) => number



let explicitCFunction: (this: C, m: number) => number;
>explicitCFunction : (m: number) => number
>this : C
>C : C
>m : number

let explicitPropertyFunction: (this: {n: number}, m: number) => number;
>explicitPropertyFunction : (m: number) => number
>this : { n: number; }
>n : number
>m : number

c.explicitC = explicitCFunction;
>c.explicitC = explicitCFunction : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>explicitCFunction : (m: number) => number

c.explicitC = function(this: C, m: number) { return this.n + m };
>c.explicitC = function(this: C, m: number) { return this.n + m } : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>function(this: C, m: number) { return this.n + m } : (m: number) => number
>this : C
>C : C
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

c.explicitProperty = explicitPropertyFunction;
>c.explicitProperty = explicitPropertyFunction : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>explicitPropertyFunction : (m: number) => number

c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m };
>c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m } : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>function(this: {n: number}, m: number) { return this.n + m } : (m: number) => number
>this : { n: number; }
>n : number
>m : number
>this.n + m : number
>this.n : number
>this : { n: number; }
>n : number
>m : number

c.explicitProperty = reconstructed.explicitProperty;
>c.explicitProperty = reconstructed.explicitProperty : (m: number) => number
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>reconstructed.explicitProperty : (m: number) => number
>reconstructed : { explicitProperty: (m: number) => number; implicitThis: (m: number) => number; n: number; }
>explicitProperty : (m: number) => number

//NOTE: this=C here, I guess?
c.explicitThis = explicitCFunction;
>c.explicitThis = explicitCFunction : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>explicitCFunction : (m: number) => number

c.explicitThis = function(this: C, m: number) { return this.n + m };
>c.explicitThis = function(this: C, m: number) { return this.n + m } : (m: number) => number
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>function(this: C, m: number) { return this.n + m } : (m: number) => number
>this : C
>C : C
>m : number
>this.n + m : number
>this.n : number
>this : C
>n : number
>m : number

// this:any compatibility
c.explicitC = function(m: number) { return this.n + m };
>c.explicitC = function(m: number) { return this.n + m } : (m: number) => any
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => any
>m : number
>this.n + m : any
>this.n : any
>this : any
>n : any
>m : number

c.explicitProperty = function(m: number) { return this.n + m };
>c.explicitProperty = function(m: number) { return this.n + m } : (m: number) => any
>c.explicitProperty : (m: number) => number
>c : C
>explicitProperty : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => any
>m : number
>this.n + m : any
>this.n : any
>this : any
>n : any
>m : number

c.explicitThis = function(m: number) { return this.n + m };
>c.explicitThis = function(m: number) { return this.n + m } : (m: number) => any
>c.explicitThis : (m: number) => number
>c : C
>explicitThis : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => any
>m : number
>this.n + m : any
>this.n : any
>this : any
>n : any
>m : number

c.implicitThis = function(m: number) { return this.n + m };
>c.implicitThis = function(m: number) { return this.n + m } : (m: number) => any
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number
>function(m: number) { return this.n + m } : (m: number) => any
>m : number
>this.n + m : any
>this.n : any
>this : any
>n : any
>m : number

c.implicitThis = reconstructed.implicitThis;
>c.implicitThis = reconstructed.implicitThis : (m: number) => number
>c.implicitThis : (m: number) => number
>c : C
>implicitThis : (m: number) => number
>reconstructed.implicitThis : (m: number) => number
>reconstructed : { explicitProperty: (m: number) => number; implicitThis: (m: number) => number; n: number; }
>implicitThis : (m: number) => number

c.explicitC = function(this: B, m: number) { return this.n + m };
>c.explicitC = function(this: B, m: number) { return this.n + m } : (m: number) => number
>c.explicitC : (m: number) => number
>c : C
>explicitC : (m: number) => number
>function(this: B, m: number) { return this.n + m } : (m: number) => number
>this : B
>B : B
>m : number
>this.n + m : number
>this.n : number
>this : B
>n : number
>m : number

// this:void compatibility
c.explicitVoid = n => n;
>c.explicitVoid = n => n : (n: number) => number
>c.explicitVoid : (m: number) => number
>c : C
>explicitVoid : (m: number) => number
>n => n : (n: number) => number
>n : number
>n : number

