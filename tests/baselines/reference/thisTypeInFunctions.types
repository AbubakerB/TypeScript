=== tests/cases/conformance/types/thisType/thisTypeInFunctions.ts ===
function f(this: { y: number }, x: number): number {
>f : (this: { y: number; }, x: number) => number
>this : { y: number; }
>y : number
>x : number

    return x + this.y;
>x + this.y : number
>x : number
>this.y : number
>this : { y: number; }
>y : number
}
function noThisSpecified(x: number): number {
>noThisSpecified : (x: number) => number
>x : number

    // for backward compatibility, this: any, so this is ok
    // (until we add --noImplicitThisAny)
    return x + this.notSpecified;
>x + this.notSpecified : any
>x : number
>this.notSpecified : any
>this : any
>notSpecified : any
}
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f };
>ok : { y: number; f: (this: { y: number; }, x: number) => number; }
>y : number
>f : (this: { y: number; }, x: number) => number
>this : { y: number; }
>y : number
>x : number
>{ y: 12, f } : { y: number; f: (this: { y: number; }, x: number) => number; }
>y : number
>12 : number
>f : (this: { y: number; }, x: number) => number

let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: noThisSpecified };
>implicitAnyOk : { notSpecified: number; f: (x: number) => number; }
>notSpecified : number
>f : (x: number) => number
>x : number
>{ notSpecified: 12, f: noThisSpecified } : { notSpecified: number; f: (x: number) => number; }
>notSpecified : number
>12 : number
>f : (x: number) => number
>noThisSpecified : (x: number) => number

ok.f(13);
>ok.f(13) : number
>ok.f : (this: { y: number; }, x: number) => number
>ok : { y: number; f: (this: { y: number; }, x: number) => number; }
>f : (this: { y: number; }, x: number) => number
>13 : number

noThisSpecified(12);
>noThisSpecified(12) : number
>noThisSpecified : (x: number) => number
>12 : number

implicitAnyOk.f(12);
>implicitAnyOk.f(12) : number
>implicitAnyOk.f : (x: number) => number
>implicitAnyOk : { notSpecified: number; f: (x: number) => number; }
>f : (x: number) => number
>12 : number

