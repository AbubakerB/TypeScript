=== tests/cases/conformance/types/thisType/thisTypeInFunctions.ts ===
// body checking
class C {
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

    n: number;
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))

    explicitThis(this: this, m: number): number {
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 3, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 3, 28))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 3, 28))
    }
    implicitThis(m: number): number {
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 6, 17))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 6, 17))
    }
    explicitC(this: C, m: number): number {
>explicitC : Symbol(explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 9, 14))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 9, 22))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 9, 22))
    }
    explicitProperty(this: {n: number}, m: number): number {
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 12, 21))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 12, 39))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 12, 26))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 12, 39))
    }
    explicitVoid(this: void, m: number): number {
>explicitVoid : Symbol(explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 15, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 15, 28))

        return m + 1;
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 15, 28))
    }
}
class D extends C { }
>D : Symbol(D, Decl(thisTypeInFunctions.ts, 18, 1))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

class B {
>B : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))

    n: number;
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 20, 9))
}
interface I {
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    a: number;
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 23, 13))

    explicitVoid1(this: void): number;
>explicitVoid1 : Symbol(explicitVoid1, Decl(thisTypeInFunctions.ts, 24, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 25, 18))

    explicitVoid2(this: void): number;
>explicitVoid2 : Symbol(explicitVoid2, Decl(thisTypeInFunctions.ts, 25, 38))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 26, 18))

    explicitStructural(this: {a: number}): number;
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 27, 23))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))

    explicitInterface(this: I): number;
>explicitInterface : Symbol(explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 28, 22))
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    // explicitThis(this: this): number; // TODO: Allow `this` types for interfaces
    implicitMethod(): number; // defaults to `this` :(
>implicitMethod : Symbol(implicitMethod, Decl(thisTypeInFunctions.ts, 28, 39))

    implicitFunction: () => number;
>implicitFunction : Symbol(implicitFunction, Decl(thisTypeInFunctions.ts, 30, 29))
}
function explicitStructural(this: { y: number }, x: number): number {
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 32, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 33, 28))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 33, 35))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 33, 48))

    return x + this.y;
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 33, 48))
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 33, 35))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 33, 33))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 33, 35))
}
function justThis(this: { y: number }): number {
>justThis : Symbol(justThis, Decl(thisTypeInFunctions.ts, 35, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 36, 18))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 25))

    return this.y;
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 25))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 36, 23))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 25))
}
function implicitThis(n: number): number {
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 38, 1))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 39, 22))

    return 12;
}
let impl: I = {
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    a: 12,
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 42, 15))

    explicitVoid2: () => this.a, // ok, this: any because it refers to some outer object (window?)
>explicitVoid2 : Symbol(explicitVoid2, Decl(thisTypeInFunctions.ts, 43, 10))

    explicitVoid1() { return 12; },
>explicitVoid1 : Symbol(explicitVoid1, Decl(thisTypeInFunctions.ts, 44, 32))

    explicitStructural() {
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 45, 35))

        return this.a;
>this.a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 27, 28))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))

    },
    explicitInterface() {
>explicitInterface : Symbol(explicitInterface, Decl(thisTypeInFunctions.ts, 48, 6))

        return this.a;
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

    },
    //explicitThis() {
        //return this.a;
    //}
    implicitMethod() {
>implicitMethod : Symbol(implicitMethod, Decl(thisTypeInFunctions.ts, 51, 6))

        return this.a;
    },
    implicitFunction: () => this.a, // ok, this: any because it refers to some outer object (window?)
>implicitFunction : Symbol(implicitFunction, Decl(thisTypeInFunctions.ts, 57, 6))
}
impl.explicitVoid1 = function () { return 12; };
>impl.explicitVoid1 : Symbol(I.explicitVoid1, Decl(thisTypeInFunctions.ts, 24, 14))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitVoid1 : Symbol(I.explicitVoid1, Decl(thisTypeInFunctions.ts, 24, 14))

impl.explicitVoid2 = () => 12;
>impl.explicitVoid2 : Symbol(I.explicitVoid2, Decl(thisTypeInFunctions.ts, 25, 38))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitVoid2 : Symbol(I.explicitVoid2, Decl(thisTypeInFunctions.ts, 25, 38))

impl.explicitStructural = function() { return this.a; };
>impl.explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>this.a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 27, 28))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))

impl.explicitInterface = function() { return this.a; };
>impl.explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

impl.explicitStructural = () => 12;
>impl.explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))

impl.explicitInterface = () => 12;
>impl.explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))

// impl.explicitThis = function () { return this.a; };
impl.implicitMethod = function () { return this.a; };
>impl.implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 28, 39))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 28, 39))

impl.implicitMethod = () => 12;
>impl.implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 28, 39))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 28, 39))

impl.implicitFunction = () => this.a; // ok, this: any because it refers to some outer object (window?)
>impl.implicitFunction : Symbol(I.implicitFunction, Decl(thisTypeInFunctions.ts, 30, 29))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitFunction : Symbol(I.implicitFunction, Decl(thisTypeInFunctions.ts, 30, 29))

// parameter checking
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f: explicitStructural };
>ok : Symbol(ok, Decl(thisTypeInFunctions.ts, 71, 3))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 71, 9))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 19))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 71, 24))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 71, 31))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 71, 44))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 71, 70))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 77))
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 32, 1))

let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: implicitThis };
>implicitAnyOk : Symbol(implicitAnyOk, Decl(thisTypeInFunctions.ts, 72, 3))
>notSpecified : Symbol(notSpecified, Decl(thisTypeInFunctions.ts, 72, 20))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 41))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 72, 46))
>notSpecified : Symbol(notSpecified, Decl(thisTypeInFunctions.ts, 72, 71))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 89))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 38, 1))

ok.f(13);
>ok.f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 19))
>ok : Symbol(ok, Decl(thisTypeInFunctions.ts, 71, 3))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 19))

implicitThis(12);
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 38, 1))

implicitAnyOk.f(12);
>implicitAnyOk.f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 41))
>implicitAnyOk : Symbol(implicitAnyOk, Decl(thisTypeInFunctions.ts, 72, 3))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 41))

let c = new C();
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

let d = new D();
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>D : Symbol(D, Decl(thisTypeInFunctions.ts, 18, 1))

let ripped = c.explicitC;
>ripped : Symbol(ripped, Decl(thisTypeInFunctions.ts, 79, 3))
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

c.explicitC(12);
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

c.explicitProperty(12);
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

c.explicitThis(12);
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

c.implicitThis(12);
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

d.explicitC(12);
>d.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

d.explicitProperty(12);
>d.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

d.explicitThis(12);
>d.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

d.implicitThis(12);
>d.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

let reconstructed: { 
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))

    explicitProperty: (this: {n : number}, m: number) => number,
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 88, 20))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 89, 23))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 89, 30))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 89, 42))

    implicitThis: (m: number) => number,
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 89, 64))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 90, 19))

    n: number,
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 90, 40))

} = { 
    explicitProperty: c.explicitProperty, 
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 92, 5))
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

    implicitThis: c.implicitThis,
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 93, 41))
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

    n: 12 
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 94, 33))

};
reconstructed.explicitProperty(11);
>reconstructed.explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 88, 20))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 88, 20))

reconstructed.implicitThis(11);
>reconstructed.implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 89, 64))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 89, 64))

// assignment checking
let unboundToSpecified: (this: { y: number }, x: number) => number = x => x + this.y; // ok, this:any
>unboundToSpecified : Symbol(unboundToSpecified, Decl(thisTypeInFunctions.ts, 101, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 101, 25))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 101, 32))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 101, 45))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 101, 68))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 101, 68))

let specifiedToSpecified: (this: {y: number}, x: number) => number = explicitStructural;
>specifiedToSpecified : Symbol(specifiedToSpecified, Decl(thisTypeInFunctions.ts, 102, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 102, 27))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 102, 34))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 102, 45))
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 32, 1))

let anyToSpecified: (this: { y: number }, x: number) => number = function(x: number): number { return x + 12; };
>anyToSpecified : Symbol(anyToSpecified, Decl(thisTypeInFunctions.ts, 103, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 103, 21))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 103, 28))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 103, 41))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 103, 74))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 103, 74))

let unspecifiedLambda: (x: number) => number = x => x + 12;
>unspecifiedLambda : Symbol(unspecifiedLambda, Decl(thisTypeInFunctions.ts, 105, 3))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 105, 24))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 105, 46))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 105, 46))

let specifiedLambda: (this: void, x: number) => number = x => x + 12;
>specifiedLambda : Symbol(specifiedLambda, Decl(thisTypeInFunctions.ts, 106, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 106, 22))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 106, 33))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 106, 56))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 106, 56))

let unspecifiedLambdaToSpecified: (this: {y: number}, x: number) => number = unspecifiedLambda;
>unspecifiedLambdaToSpecified : Symbol(unspecifiedLambdaToSpecified, Decl(thisTypeInFunctions.ts, 107, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 107, 35))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 107, 42))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 107, 53))
>unspecifiedLambda : Symbol(unspecifiedLambda, Decl(thisTypeInFunctions.ts, 105, 3))

let specifiedLambdaToSpecified: (this: {y: number}, x: number) => number = specifiedLambda;
>specifiedLambdaToSpecified : Symbol(specifiedLambdaToSpecified, Decl(thisTypeInFunctions.ts, 108, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 108, 33))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 108, 40))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 108, 51))
>specifiedLambda : Symbol(specifiedLambda, Decl(thisTypeInFunctions.ts, 106, 3))


let explicitCFunction: (this: C, m: number) => number;
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 111, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 111, 24))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 111, 32))

let explicitPropertyFunction: (this: {n: number}, m: number) => number;
>explicitPropertyFunction : Symbol(explicitPropertyFunction, Decl(thisTypeInFunctions.ts, 112, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 112, 31))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 112, 38))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 112, 49))

c.explicitC = explicitCFunction;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 111, 3))

c.explicitC = function(this: C, m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 114, 23))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 114, 31))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 114, 31))

c.explicitProperty = explicitPropertyFunction;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>explicitPropertyFunction : Symbol(explicitPropertyFunction, Decl(thisTypeInFunctions.ts, 112, 3))

c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m };
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 116, 30))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 116, 37))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 116, 48))
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 116, 37))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 116, 35))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 116, 37))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 116, 48))

c.explicitProperty = reconstructed.explicitProperty;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>reconstructed.explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 88, 20))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 88, 20))

// lambdas are assignable to anything
c.explicitC = m => m;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 120, 13))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 120, 13))

c.explicitThis = m => m;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 121, 16))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 121, 16))

c.explicitProperty = m => m;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 122, 20))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 122, 20))

// this inside lambdas refer to outer scope
// the outer-scoped lambda at top-level is still just `any`
c.explicitC = m => m + this.n;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 126, 13))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 126, 13))

c.explicitThis = m => m + this.n;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 127, 16))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 127, 16))

c.explicitProperty = m => m + this.n;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 128, 20))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 128, 20))

//NOTE: this=C here, I guess?
c.explicitThis = explicitCFunction;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 111, 3))

c.explicitThis = function(this: C, m: number) { return this.n + m };
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 132, 26))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 132, 34))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 132, 34))

// this:any compatibility
c.explicitC = function(m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 135, 23))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 135, 23))

c.explicitProperty = function(m: number) { return this.n + m };
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 136, 30))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 136, 30))

c.explicitThis = function(m: number) { return this.n + m };
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 137, 26))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 137, 26))

c.implicitThis = function(m: number) { return this.n + m };
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 138, 26))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 138, 26))

c.implicitThis = reconstructed.implicitThis;
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>reconstructed.implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 89, 64))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 89, 64))

c.explicitC = function(this: B, m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 141, 23))
>B : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 141, 31))
>this.n : Symbol(B.n, Decl(thisTypeInFunctions.ts, 20, 9))
>this : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))
>n : Symbol(B.n, Decl(thisTypeInFunctions.ts, 20, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 141, 31))

// this:void compatibility
c.explicitVoid = n => n;
>c.explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 144, 16))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 144, 16))

