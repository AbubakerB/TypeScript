=== tests/cases/conformance/types/thisType/thisTypeInFunctions.ts ===
// body checking
class C {
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

    n: number;
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))

    explicitThis(this: this, m: number): number {
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 3, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 3, 28))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 3, 28))
    }
    implicitThis(m: number): number {
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 6, 17))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 6, 17))
    }
    explicitC(this: C, m: number): number {
>explicitC : Symbol(explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 9, 14))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 9, 22))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 9, 22))
    }
    explicitProperty(this: {n: number}, m: number): number {
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 12, 21))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 12, 39))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 12, 26))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 12, 39))
    }
    explicitVoid(this: void, m: number): number {
>explicitVoid : Symbol(explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 15, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 15, 28))

        return m + 1;
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 15, 28))
    }
}
class D extends C { }
>D : Symbol(D, Decl(thisTypeInFunctions.ts, 18, 1))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

class B {
>B : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))

    n: number;
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 20, 9))
}
function f(this: { y: number }, x: number): number {
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 22, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 23, 11))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 23, 18))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 23, 31))

    return x + this.y;
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 23, 31))
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 23, 18))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 23, 16))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 23, 18))
}
function noThisSpecified(x: number): number {
>noThisSpecified : Symbol(noThisSpecified, Decl(thisTypeInFunctions.ts, 25, 1))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 26, 25))

    // for backward compatibility, this: any, so this is ok
    // (until we add --noImplicitThisAny)
    return x + this.notSpecified;
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 26, 25))
}
function justThis(this: { y: number }): number {
>justThis : Symbol(justThis, Decl(thisTypeInFunctions.ts, 30, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 31, 18))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 31, 25))

    return this.y;
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 31, 25))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 31, 23))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 31, 25))
}

// parameter checking
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f };
>ok : Symbol(ok, Decl(thisTypeInFunctions.ts, 36, 3))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 9))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 36, 19))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 36, 24))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 31))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 36, 44))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 70))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 36, 77))

let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: noThisSpecified };
>implicitAnyOk : Symbol(implicitAnyOk, Decl(thisTypeInFunctions.ts, 37, 3))
>notSpecified : Symbol(notSpecified, Decl(thisTypeInFunctions.ts, 37, 20))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 37, 41))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 37, 46))
>notSpecified : Symbol(notSpecified, Decl(thisTypeInFunctions.ts, 37, 71))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 37, 89))
>noThisSpecified : Symbol(noThisSpecified, Decl(thisTypeInFunctions.ts, 25, 1))

ok.f(13);
>ok.f : Symbol(f, Decl(thisTypeInFunctions.ts, 36, 19))
>ok : Symbol(ok, Decl(thisTypeInFunctions.ts, 36, 3))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 36, 19))

noThisSpecified(12);
>noThisSpecified : Symbol(noThisSpecified, Decl(thisTypeInFunctions.ts, 25, 1))

implicitAnyOk.f(12);
>implicitAnyOk.f : Symbol(f, Decl(thisTypeInFunctions.ts, 37, 41))
>implicitAnyOk : Symbol(implicitAnyOk, Decl(thisTypeInFunctions.ts, 37, 3))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 37, 41))

let c = new C();
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

let d = new D();
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 43, 3))
>D : Symbol(D, Decl(thisTypeInFunctions.ts, 18, 1))

let ripped = c.explicitC;
>ripped : Symbol(ripped, Decl(thisTypeInFunctions.ts, 44, 3))
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

c.explicitC(12);
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

c.explicitProperty(12);
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

c.explicitThis(12);
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

c.implicitThis(12);
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

d.explicitC(12);
>d.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 43, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

d.explicitProperty(12);
>d.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 43, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

d.explicitThis(12);
>d.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 43, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

d.implicitThis(12);
>d.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 43, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

let reconstructed: { 
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 53, 3))

    explicitProperty: (this: {n : number}, m: number) => number,
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 53, 20))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 54, 23))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 54, 30))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 54, 42))

    implicitThis: (m: number) => number,
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 54, 64))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 55, 19))

    n: number,
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 55, 40))

} = { 
    explicitProperty: c.explicitProperty, 
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 57, 5))
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

    implicitThis: c.implicitThis,
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 58, 41))
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

    n: 12 
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 59, 33))

};
reconstructed.explicitProperty(11);
>reconstructed.explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 53, 20))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 53, 3))
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 53, 20))

reconstructed.implicitThis(11);
>reconstructed.implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 54, 64))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 53, 3))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 54, 64))

// assignment checking
let specifiedToAny: (x: number) => number = f;
>specifiedToAny : Symbol(specifiedToAny, Decl(thisTypeInFunctions.ts, 66, 3))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 66, 21))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 22, 1))

let specifiedToSpecified: (this: {y: number}, x: number) => number = f;
>specifiedToSpecified : Symbol(specifiedToSpecified, Decl(thisTypeInFunctions.ts, 67, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 67, 27))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 67, 34))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 67, 45))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 22, 1))

let anyToSpecified: (this: { y: number }, x: number) => number = function(x: number): number { return x + 12; };
>anyToSpecified : Symbol(anyToSpecified, Decl(thisTypeInFunctions.ts, 68, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 68, 21))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 68, 28))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 68, 41))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 68, 74))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 68, 74))

let unspecifiedLambda: (x: number) => number = x => x + 12;
>unspecifiedLambda : Symbol(unspecifiedLambda, Decl(thisTypeInFunctions.ts, 70, 3))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 70, 24))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 70, 46))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 70, 46))

let specifiedLambda: (this: void, x: number) => number = x => x + 12;
>specifiedLambda : Symbol(specifiedLambda, Decl(thisTypeInFunctions.ts, 71, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 71, 22))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 71, 33))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 71, 56))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 71, 56))

let unspecifiedLambdaToSpecified: (this: {y: number}, x: number) => number = unspecifiedLambda;
>unspecifiedLambdaToSpecified : Symbol(unspecifiedLambdaToSpecified, Decl(thisTypeInFunctions.ts, 72, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 72, 35))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 72, 42))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 72, 53))
>unspecifiedLambda : Symbol(unspecifiedLambda, Decl(thisTypeInFunctions.ts, 70, 3))



let explicitCFunction: (this: C, m: number) => number;
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 76, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 76, 24))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 76, 32))

let explicitPropertyFunction: (this: {n: number}, m: number) => number;
>explicitPropertyFunction : Symbol(explicitPropertyFunction, Decl(thisTypeInFunctions.ts, 77, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 77, 31))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 77, 38))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 77, 49))

c.explicitC = explicitCFunction;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 76, 3))

c.explicitC = function(this: C, m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 79, 23))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 79, 31))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 79, 31))

c.explicitProperty = explicitPropertyFunction;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>explicitPropertyFunction : Symbol(explicitPropertyFunction, Decl(thisTypeInFunctions.ts, 77, 3))

c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m };
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 81, 30))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 81, 37))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 81, 48))
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 81, 37))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 81, 35))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 81, 37))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 81, 48))

c.explicitProperty = reconstructed.explicitProperty;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>reconstructed.explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 53, 20))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 53, 3))
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 53, 20))

//NOTE: this=C here, I guess?
c.explicitThis = explicitCFunction;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 76, 3))

c.explicitThis = function(this: C, m: number) { return this.n + m };
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 86, 26))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 86, 34))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 86, 34))

// this:any compatibility
c.explicitC = function(m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 89, 23))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 89, 23))

c.explicitProperty = function(m: number) { return this.n + m };
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 90, 30))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 90, 30))

c.explicitThis = function(m: number) { return this.n + m };
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 91, 26))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 91, 26))

c.implicitThis = function(m: number) { return this.n + m };
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 92, 26))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 92, 26))

c.implicitThis = reconstructed.implicitThis;
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>reconstructed.implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 54, 64))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 53, 3))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 54, 64))

c.explicitC = function(this: B, m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 95, 23))
>B : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 95, 31))
>this.n : Symbol(B.n, Decl(thisTypeInFunctions.ts, 20, 9))
>this : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))
>n : Symbol(B.n, Decl(thisTypeInFunctions.ts, 20, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 95, 31))

// this:void compatibility
c.explicitVoid = n => n;
>c.explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 98, 16))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 98, 16))

